\section{\lr{Warp Scheduler}}
در این سوال فرض می‌کنیم که
\lr{One-level round-robin}
بدون توجه به
\lr{stall}ها
یک بازه‌ی زمانی مشخص را به هر
\lr{warp}
می‌دهد.
\begin{enumerate}
    \item به نظرم در این سناریو تمام الگوریتم‌ها به خوبی عمل می‌کنند چرا که هیچ کدام ترد‌ها را تکه تکه نمی‌کنند.
    اما اگر کش هر
    \lr{SM}
    را نیز لحاظ کنیم به نظرم
    \lr{Greedy-then-oldest} و \lr{One-level round-robin}
    بدترین عملکرد را دارد چرا که داده‌های کش فراموش می‌شوند. بهترین عملکرد را نیز
    \lr{Two-level round-robin}
    دارد.
    \item در این حالت نیز به نظرم
    \lr{One-level round-robin} و \lr{Two-level round-robin}
    عملکرد خوبی دارد. چرا که دیتای مموری را برای ترد‌های دیگر بعد از تمام شدن کارشان نگه می‌دارند.
    اما
    \lr{Greedy-then-oldest}
    عملکرد خوبی ندارد چرا که وقتی که به
    \lr{stall}
    می‌خوریم یحتمل دیتای ترد‌های دیگر آماده نیست.
    \item \lr{Greedy-then-oldest} بهترین عملکرد را دارد چرا که بلافاصله \lr{context switch}
    را انجام می‌دهد. از آن طرف
    \lr{One-level round-robin}
    صبر می‌کند که \lr{quantum time} تمام شود پس بدترین عملکرد را دارد. حد وسط هم
    \lr{Two-level round-robin} حداقل تمام \lr{SM}ها
    با هم
    \lr{stall}
    نمی‌شوند.
    \item به نظرم در کل \lr{Two-level round-robin} بهتر است چرا که به عبارتی
    \lr{best of two worlds}
    است!
\end{enumerate}