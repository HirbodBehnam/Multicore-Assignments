\section{\lr{Warp Scheduler}}
\begin{enumerate}
    \item به نظرم در این سناریو تمام الگوریتم‌ها به خوبی عمل می‌کنند چرا که هیچ کدام ترد‌ها را تکه تکه نمی‌کنند.
    اما اگر کش هر
    \lr{SM}
    را نیز لحاظ کنیم به نظرم
    \lr{Greedy-then-oldest}
    بدترین عملکرد را دارد چرا که داده‌های کش فراموش می‌شوند و
    \lr{One-level round-robin}
    بهترین عملکرد را دارد چرا که حتی زمانی که
    \lr{stall}
    رخ می‌دهد اجرا را متوقف نمی‌کند.
    \item در این حالت نیز به نظرم
    \lr{One-level round-robin} و \lr{Two-level round-robin}
    عملکرد خوبی دارد. چرا که دیتای مموری را برای ترد‌های دیگر بعد از تمام شدن کارشان نگه می‌دارند.
    \item \lr{Greedy-then-oldest} بهترین عملکرد را دارد چرا که بلافاصله \lr{context switch}
    را انجام می‌دهد. از آن طرف
    \lr{One-level round-robin}
    صبر می‌کند که کار ترد تمام شود پس بدترین عملکرد را دارد. حد وسط هم
    \lr{Two-level round-robin} حداقل تمام \lr{SM}ها
    با هم
    \lr{stall}
    نمی‌شوند.
    \item به نظرم در کل \lr{Two-level round-robin} بهتر است چرا که به عبارتی
    \lr{best of two worlds}
    است!
\end{enumerate}